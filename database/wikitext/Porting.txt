In software engineering, porting is the process of adapting software for the purpose of achieving some form of execution in a computing environment that is different from the one that a given program (meant for such execution) was originally designed for (e.g., different CPU, operating system, or third party library). The term is also used when software/hardware is changed to make them usable in different environments.Software is portable when the cost of porting it to a new platform is significantly less than the cost of writing it from scratch.  The lower the cost of porting software relative to its implementation cost, the more portable it is said to be.


== Etymology ==
The term "port" is derived from the Latin portƒÅre, meaning "to carry".  When code is not compatible with a particular operating system or architecture, the code must be "carried" to the new system.
The term is not generally applied to the process of adapting software to run with less memory on the same CPU and operating system.
Software developers often claim that the software they write is portable, meaning that little effort is needed to adapt it to a new environment.  The amount of effort actually needed depends on several factors, including the extent to which the original environment (the source platform) differs from the new environment (the target platform), the experience of the original authors in knowing which programming language constructs and third party library calls are unlikely to be portable, and the amount of effort invested by the original authors in only using portable constructs (platform specific constructs often provide a cheaper solution).


== History ==
The number of significantly different CPUs and operating systems used on the desktop today is much smaller than in the past. The dominance of the x86 architecture means that most desktop software is never ported to a different CPU.  In that same market, the choice of operating systems has effectively been reduced to three: Microsoft Windows, macOS, and Linux. However, in the embedded systems and mobile markets, portability remains a significant issue, with the ARM being a widely used alternative.
International standards, such as those promulgated by the ISO, greatly facilitate porting by specifying details of the computing environment in a way that helps reduce differences between different standards-conforming platforms. Writing software that stays within the bounds specified by these standards represents a practical although nontrivial effort. Porting such a program between two standards-compliant platforms (such as POSIX.1) can be just a matter of loading the source code and recompiling it on the new platform. However, practitioners often find that various minor corrections are required, due to subtle platform differences. Most standards suffer from "gray areas" where differences in interpretation of standards lead to small variations from platform to platform.
There also exists an ever-increasing number of tools to facilitate porting, such as the GNU Compiler Collection, which provides consistent programming languages on different platforms, and Autotools, which automates the detection of minor variations in the environment and adapts the software accordingly before compilation.
The compilers for some high-level programming languages (e.g. Eiffel, Esterel) gain portability by outputting source code in another high level intermediate language (such as C) for which compilers for many platforms are generally available.
Two activities related to (but distinct from) porting are emulating and cross-compiling.


== Porting compilers ==
Instead of translating directly into machine code, modern compilers translate to a machine independent intermediate code in order to enhance portability of the compiler and minimize design efforts. 
The intermediate language defines a virtual machine that can execute all programs written in the intermediate language (a machine is defined by its language and vice versa). The intermediate code instructions are translated into equivalent machine code sequences by a code generator to create executable code. It is also possible to skip the generation of machine code by actually implementing an interpreter or JIT for the virtual machine.The use of intermediate code enhances portability of the compiler, because only the machine dependent code (the interpreter or the code generator) of the compiler itself  needs to be ported to the target machine. The remainder of the compiler can be imported as intermediate code and then further processed by the ported code generator or interpreter, thus producing the compiler software or directly executing the intermediate code on the interpreter.
The machine independent part can be developed and tested on another machine (the host machine). This greatly reduces design efforts, because the machine independent part needs to be developed only once to create portable intermediate code.An interpreter is less complex and therefore easier to port than a code generator, because it is not able to do code optimizations due to its limited view of the program code (it only sees one instruction at a time, and you need a sequence to do optimization). Some interpreters are extremely easy to port, because they only make minimal assumptions about the instruction set of the underlying hardware. As a result, the virtual machine is even simpler than the target CPU.Writing the compiler sources entirely in the programming language the compiler is supposed to translate, makes the following approach, better known as compiler bootstrapping, feasible on the target machine: 

Port the interpreter. This needs to be coded in assembly code, using an already present assembler on the target.
Adapt the source of the code generator to the new machine.
Execute the adapted source using the interpreter with the code generator source as input. This will generate the machine code for the code generator.The difficult part of coding the optimization routines is done using the high-level language instead of the assembly language of the target.
According to the designers of the BCPL language, interpreted code (in the BCPL case) is more compact than machine code; typically by a factor of two to one. Interpreted code however runs about ten times slower than compiled code on the same machine.The designers of the Java programming language try to take advantage of the compactness of interpreted code, because a Java program may need to be transmitted over the Internet before execution can start on the target's Java virtual machine (JVM).


== Porting of video games ==

Porting is also the term used when a video game designed to run on one platform, be it an arcade, video game console, or personal computer, is converted to run on a different platform, perhaps with some minor differences. From the beginning of video games through to the 1990s, "ports", at the time often known as "conversions", were often not true ports, but rather reworked versions of the games due to limitations of different systems. For example, the 1982 game The Hobbit, a text adventure augmented with graphic images, has significantly different graphic styles across the range of personal computers that its ports were developed for. However, many 21st century video games are developed using software (often in C++) that can output code for one or more consoles as well as for a PC without the need for actual porting (instead relying on the common porting of individual component libraries).Porting arcade games to home systems with inferior hardware was difficult. The ported version of Pac-Man for the Atari 2600 omitted many of the visual features of the original game to compensate for the lack of ROM space and the hardware struggled when multiple ghosts appeared on the screen creating a flickering effect. The poor performance of the Atari 2600 Pac-Man is cited by some scholars as a cause of the video game crash of 1983.Many early ports suffered significant gameplay quality issues because computers greatly differed. Richard Garriott stated in 1984 at Origins Game Fair that Origin Systems developed computer games for the Apple II series first then ported them to Commodore 64 and Atari 8-bit, because the latter machines' sprites and other sophisticated features made porting from them to Apple "far more difficult, perhaps even impossible". Reviews complained of ports that suffered from "Apple conversionitis", retaining the Apple's "lousy sound and black-white-green-purple graphics"; after Garriott's statement, when Dan Bunten asked "Atari and Commodore people in the audience, are you happy with the Apple rewrites?" the audience shouted "No!" Garriott responded, "[otherwise] the Apple version will never get done. From a publisher's point of view that's not money wise".Others worked differently. Ozark Softscape, for example, wrote M.U.L.E. for the Atari first because it preferred to develop for the most advanced computers, removing or altering features as necessary during porting. Such a policy was not always feasible; Bunten stated that "M.U.L.E. can't be done for an Apple", and that the non-Atari versions of The Seven Cities of Gold were inferior. Compute!'s Gazette wrote in 1986 that when porting from Atari to Commodore the original was usually superior. The latter's games' quality improved when developers began creating new software for it in late 1983, the magazine stated.In porting arcade games, the terms "arcade perfect" or "arcade accurate" were often used to describe how closely the gameplay, graphics, and other assets on the ported version matched the arcade version. Many arcade ports in the early 1980s were far from arcade perfect as home consoles and computers lacked the sophisticated hardware in arcade games, but games could still approximate the gameplay. Notably, Space Invaders on the Atari VCS became the console's killer app despite its differences, while the later Pac-Man port was notorious for its deviations from the arcade version. Arcade-accurate games became more prevalent starting in the 1990s, starting with the Neo Geo system from SNK, which offered both a home console and an arcade system with more advanced versions of the home console's main hardware. This allowed near-arcade perfect games to be played at home. Further consoles such as the PlayStation and Dreamcast, also based on arcade hardware, made arcade-perfect games a reality.A "console port" is a game that was originally made for a console before an identical version is created which can be played on a personal computer. This term has been widely used by the gaming community. The process of porting a game from a console to a PC is often regarded negatively due to the higher levels of performance that computers generally have being underutilized, partially due to console hardware being fixed throughout their run (with games being developed for console specs), while PCs become more powerful as hardware evolves, but also due to ported games sometimes being poorly optimized for PCs, or lazily ported. While broadly similar, architectural differences may exist such as the use of unified memory on a console.


== See also ==
Console emulator
Cross-platform
Language binding
List of system quality attributes
Poshlib
Program transformation
Software portability
Source port
Write once, compile anywhere
Meaning of unported


== Notes ==


== References ==

Richards, Martin; Whitby-Strevens, Colin (1984). BCPL, the language and its compiler. ISBN 0-521-28681-6.
Tanenbaum, Andrew S. (1984). Structured computer organization. ISBN 0-13-854605-3.